<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Japanese Verb ã¦-form Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f5f5f9;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    .app {
      max-width: 480px;
      width: 100%;
      padding: 16px;
      box-sizing: border-box;
    }
    .card {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      padding: 20px;
      margin-bottom: 16px;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 4px;
    }
    .subtitle {
      font-size: 0.85rem;
      color: #666;
      margin-bottom: 8px;
    }
    .kana-display {
      font-size: 2.4rem;
      text-align: center;
      margin: 12px 0 8px;
      line-height: 1.3;
    }
    .question-info {
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      color: #555;
    }
    .score-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    .btn {
      display: block;
      width: 100%;
      padding: 10px 12px;
      margin: 6px 0;
      border-radius: 999px;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      background: #e0e0ff;
      transition: transform 0.05s ease, box-shadow 0.05s ease, background 0.1s ease;
    }
    .btn-primary {
      background: #4f46e5;
      color: #fff;
    }
    .btn-small {
      font-size: 0.85rem;
      padding: 6px 10px;
      width: auto;
      display: inline-block;
    }
    .feedback {
      margin-top: 10px;
      font-size: 0.9rem;
      min-height: 2.3em;
      white-space: pre-line;
    }
    .feedback.correct { color: #0c7a3a; }
    .feedback.wrong { color: #b91c1c; }

    .badge-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .badge {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 999px;
      background: #eef2ff;
      color: #312e81;
    }
    .mistake-list {
      font-size: 0.85rem;
      max-height: 150px;
      overflow-y: auto;
    }
    .mistake-item {
      display: flex;
      justify-content: space-between;
      padding: 2px 0;
    }
  </style>
</head>

<body>
<div class="app">

  <div class="card">
    <h1>Verb ã¦-form Quiz</h1>
    <div class="subtitle">
      10 questions per round Â· 3 choices Â· choose the correct ã¦-form
    </div>

    <div class="question-info">
      <div>Question: <span id="questionNumber">0</span> / 10</div>
      <div>Round: <span id="roundCount">0</span></div>
    </div>

    <div class="score-info">
      <div>Score: <span id="score">0</span></div>
      <div>Streak: <span id="streak">0</span> (Max: <span id="maxStreak">0</span>)</div>
    </div>

    <div class="kana-display" id="kanaDisplay">ãƒ¼</div>

    <div style="text-align:center;">
      <button class="btn btn-small" id="playAudioBtn">ğŸ”Š Play audio</button>
    </div>

    <button class="btn" id="choice1"></button>
    <button class="btn" id="choice2"></button>
    <button class="btn" id="choice3"></button>

    <div class="feedback" id="feedback"></div>

    <div id="roundEnd" style="display:none; margin-top:16px;">
      <strong>Round finished!</strong><br>
      Correct: <span id="roundCorrect">0</span> / 10<br>
      <button class="btn btn-primary btn-small" id="nextRoundBtn">Next round</button>
    </div>
  </div>

  <div class="card">
    <div><strong>Badges</strong></div>
    <div class="badge-list" id="badgeList"></div>
  </div>

  <div class="card">
    <div><strong>Mistakes</strong></div>
    <div class="mistake-list" id="mistakeList"></div>
  </div>

</div>

<script>
/* ==========================
   Verb list & metadata
   ========================== */
const VERB_LIST = [
  // group: "godan" | "ichidan" | "suru" | "kuru"
  { id: "aru",        display: "ã‚ã‚‹",                 kana: "ã‚ã‚‹",             group: "godan",  en: "to exist (things)",          pt: "existir / haver / ter" },
  { id: "iru_ex",     display: "ã„ã‚‹",                 kana: "ã„ã‚‹",             group: "ichidan",en: "to exist (people/animals)", pt: "existir / estar / ter" },
  { id: "iku",        display: "è¡Œï¼ˆã„ï¼‰ã",           kana: "ã„ã",             group: "godan",  en: "to go",                      pt: "ir" },
  { id: "kuru",       display: "æ¥ï¼ˆãï¼‰ã‚‹",           kana: "ãã‚‹",             group: "kuru",   en: "to come",                    pt: "vir" },
  { id: "kaeru",      display: "å¸°ï¼ˆã‹ãˆï¼‰ã‚‹",         kana: "ã‹ãˆã‚‹",           group: "godan",  en: "to return / go back",        pt: "voltar" },
  { id: "suru",       display: "ã™ã‚‹",                 kana: "ã™ã‚‹",             group: "suru",   en: "to do",                      pt: "fazer" },

  { id: "taberu",     display: "é£Ÿï¼ˆãŸï¼‰ã¹ã‚‹",         kana: "ãŸã¹ã‚‹",           group: "ichidan",en: "to eat",                     pt: "comer" },
  { id: "nomu",       display: "é£²ï¼ˆã®ï¼‰ã‚€",           kana: "ã®ã‚€",             group: "godan",  en: "to drink",                   pt: "beber" },
  { id: "miru",       display: "è¦‹ï¼ˆã¿ï¼‰ã‚‹",           kana: "ã¿ã‚‹",             group: "ichidan",en: "to see / watch",             pt: "ver" },
  { id: "yomu",       display: "èª­ï¼ˆã‚ˆï¼‰ã‚€",           kana: "ã‚ˆã‚€",             group: "godan",  en: "to read",                    pt: "ler" },
  { id: "kiku",       display: "èï¼ˆãï¼‰ã",           kana: "ãã",             group: "godan",  en: "to listen / ask",            pt: "ouvir / perguntar" },
  { id: "hanasu",     display: "è©±ï¼ˆã¯ãªï¼‰ã™",         kana: "ã¯ãªã™",           group: "godan",  en: "to speak",                   pt: "falar" },
  { id: "iu",         display: "è¨€ï¼ˆã„ï¼‰ã†",           kana: "ã„ã†",             group: "godan",  en: "to say",                     pt: "dizer" },
  { id: "kaku",       display: "æ›¸ï¼ˆã‹ï¼‰ã",           kana: "ã‹ã",             group: "godan",  en: "to write",                   pt: "escrever" },
  { id: "matsu",      display: "å¾…ï¼ˆã¾ï¼‰ã¤",           kana: "ã¾ã¤",             group: "godan",  en: "to wait",                    pt: "esperar" },
  { id: "tsukuru",    display: "ä½œï¼ˆã¤ãï¼‰ã‚‹",         kana: "ã¤ãã‚‹",           group: "godan",  en: "to make",                    pt: "fazer / criar" },
  { id: "tsukau",     display: "ä½¿ï¼ˆã¤ã‹ï¼‰ã†",         kana: "ã¤ã‹ã†",           group: "godan",  en: "to use",                     pt: "usar" },
  { id: "au",         display: "ä¼šï¼ˆã‚ï¼‰ã†",           kana: "ã‚ã†",             group: "godan",  en: "to meet",                    pt: "encontrar" },
  { id: "hajimeru",   display: "å§‹ï¼ˆã¯ã˜ï¼‰ã‚ã‚‹",       kana: "ã¯ã˜ã‚ã‚‹",         group: "ichidan",en: "to start",                   pt: "comeÃ§ar" },
  { id: "owaru",      display: "çµ‚ï¼ˆãŠï¼‰ã‚ã‚‹",         kana: "ãŠã‚ã‚‹",           group: "godan",  en: "to finish",                  pt: "terminar / acabar" },
  { id: "akeru",      display: "é–‹ï¼ˆã‚ï¼‰ã‘ã‚‹",         kana: "ã‚ã‘ã‚‹",           group: "ichidan",en: "to open",                    pt: "abrir" },
  { id: "shimeru",    display: "é–‰ï¼ˆã—ï¼‰ã‚ã‚‹",         kana: "ã—ã‚ã‚‹",           group: "ichidan",en: "to close",                   pt: "fechar" },
  { id: "deru",       display: "å‡ºï¼ˆã§ï¼‰ã‚‹",           kana: "ã§ã‚‹",             group: "ichidan",en: "to leave / exit",            pt: "sair" },
  { id: "hairu",      display: "å…¥ï¼ˆã¯ã„ï¼‰ã‚‹",         kana: "ã¯ã„ã‚‹",           group: "godan",  en: "to enter",                   pt: "entrar" },
  { id: "noru",       display: "ä¹—ï¼ˆã®ï¼‰ã‚‹",           kana: "ã®ã‚‹",             group: "godan",  en: "to ride / get on",           pt: "apanhar / andar" },
  { id: "oriru",      display: "é™ï¼ˆãŠï¼‰ã‚Šã‚‹",         kana: "ãŠã‚Šã‚‹",           group: "ichidan",en: "to get off",                 pt: "descer / sair" },
  { id: "kau",        display: "è²·ï¼ˆã‹ï¼‰ã†",           kana: "ã‹ã†",             group: "godan",  en: "to buy",                     pt: "comprar" },
  { id: "oku",        display: "ç½®ï¼ˆãŠï¼‰ã",           kana: "ãŠã",             group: "godan",  en: "to put / place",             pt: "colocar" },
  { id: "toru",       display: "å–ï¼ˆã¨ï¼‰ã‚‹",           kana: "ã¨ã‚‹",             group: "godan",  en: "to take",                    pt: "tirar" },
  { id: "tsukeru",    display: "ã¤ã‘ã‚‹",               kana: "ã¤ã‘ã‚‹",           group: "ichidan",en: "to turn on",                 pt: "ligar" },
  { id: "kesu",       display: "æ¶ˆï¼ˆã‘ï¼‰ã™",           kana: "ã‘ã™",             group: "godan",  en: "to turn off",                pt: "desligar" },
  { id: "neru",       display: "å¯ï¼ˆã­ï¼‰ã‚‹",           kana: "ã­ã‚‹",             group: "ichidan",en: "to sleep",                   pt: "dormir" },
  { id: "okiru",      display: "èµ·ï¼ˆãŠï¼‰ãã‚‹",         kana: "ãŠãã‚‹",           group: "ichidan",en: "to wake up",                 pt: "acordar" },
  { id: "hashiru",    display: "èµ°ï¼ˆã¯ã—ï¼‰ã‚‹",         kana: "ã¯ã—ã‚‹",           group: "godan",  en: "to run",                     pt: "correr" },
  { id: "aruku",      display: "æ­©ï¼ˆã‚ã‚‹ï¼‰ã",         kana: "ã‚ã‚‹ã",           group: "godan",  en: "to walk",                    pt: "andar" },
  { id: "oyogu",      display: "æ³³ï¼ˆãŠã‚ˆï¼‰ã",         kana: "ãŠã‚ˆã",           group: "godan",  en: "to swim",                    pt: "nadar" },
  { id: "wakaru",     display: "åˆ†ï¼ˆã‚ï¼‰ã‹ã‚‹",         kana: "ã‚ã‹ã‚‹",           group: "godan",  en: "to understand",              pt: "perceber / entender" },
  { id: "oboeru",     display: "è¦šï¼ˆãŠã¼ï¼‰ãˆã‚‹",       kana: "ãŠã¼ãˆã‚‹",         group: "ichidan",en: "to remember",                pt: "lembrar / memorizar" },
  { id: "wasureru",   display: "å¿˜ï¼ˆã‚ã™ï¼‰ã‚Œã‚‹",       kana: "ã‚ã™ã‚Œã‚‹",         group: "ichidan",en: "to forget",                  pt: "esquecer" },
  { id: "shiru",      display: "çŸ¥ï¼ˆã—ï¼‰ã‚‹",           kana: "ã—ã‚‹",             group: "godan",  en: "to know",                    pt: "saber / conhecer" },
  { id: "dekiru",     display: "ã§ãã‚‹",               kana: "ã§ãã‚‹",           group: "ichidan",en: "can / be able to",            pt: "poder" },
  { id: "motsu",      display: "æŒï¼ˆã‚‚ï¼‰ã¤",           kana: "ã‚‚ã¤",             group: "godan",  en: "to hold / have",             pt: "ter / segurar" },
  { id: "sumu",       display: "ä½ï¼ˆã™ï¼‰ã‚€",           kana: "ã™ã‚€",             group: "godan",  en: "to live",                    pt: "viver / morar" },
  { id: "hiku",       display: "ã²ãï¼ˆå¼¾ãï¼‰",         kana: "ã²ã",             group: "godan",  en: "to play (instrument)",       pt: "tocar (instrumento)" },
  { id: "utau",       display: "æ­Œï¼ˆã†ãŸï¼‰ã†",         kana: "ã†ãŸã†",           group: "godan",  en: "to sing",                    pt: "cantar" },
  { id: "hataraku",   display: "åƒï¼ˆã¯ãŸã‚‰ï¼‰ã",       kana: "ã¯ãŸã‚‰ã",         group: "godan",  en: "to work",                    pt: "trabalhar" },

  { id: "benkyou_suru", display: "å‹‰å¼·ï¼ˆã¹ã‚“ãã‚‡ã†ï¼‰ã™ã‚‹", kana: "ã¹ã‚“ãã‚‡ã†ã™ã‚‹", group: "suru_compound", en: "to study", pt: "estudar" },
  { id: "renshuu_suru", display: "ç·´ç¿’ï¼ˆã‚Œã‚“ã—ã‚…ã†ï¼‰ã™ã‚‹", kana: "ã‚Œã‚“ã—ã‚…ã†ã™ã‚‹", group: "suru_compound", en: "to practice", pt: "praticar" },
  { id: "kekkon_suru", display: "çµå©šï¼ˆã‘ã£ã“ã‚“ï¼‰ã™ã‚‹",     kana: "ã‘ã£ã“ã‚“ã™ã‚‹",   group: "suru_compound", en: "to marry", pt: "casar" },
  { id: "ryokou_suru", display: "æ—…è¡Œï¼ˆã‚Šã‚‡ã“ã†ï¼‰ã™ã‚‹",     kana: "ã‚Šã‚‡ã“ã†ã™ã‚‹",   group: "suru_compound", en: "to travel", pt: "viajar" },
  { id: "sanpo_suru",  display: "æ•£æ­©ï¼ˆã•ã‚“ã½ï¼‰ã™ã‚‹",       kana: "ã•ã‚“ã½ã™ã‚‹",     group: "suru_compound", en: "to take a walk", pt: "passear" },

  { id: "shawaa_aberu", display: "ã‚·ãƒ£ãƒ¯ãƒ¼ã‚’æµ´ï¼ˆã‚ï¼‰ã³ã‚‹", kana: "ã—ã‚ƒã‚ãƒ¼ã‚’ã‚ã³ã‚‹", group: "ichidan", en: "to take a shower", pt: "tomar duche" }
];

const TOTAL_PER_ROUND = 10;
const REVIEW_PER_ROUND = 3;
const STORAGE_KEY = "verb_teform_quiz_state_v1";

/* ==========================
   State
   ========================== */
let state = {
  learningQueue: [],
  index: 0,
  reviewPool: {},
  stats: {
    score: 0,
    currentStreak: 0,
    maxStreak: 0,
    totalSeen: 0,
    totalCorrect: 0,
    roundsPlayed: 0,
    badges: []
  },
  currentRound: {
    questionList: [],
    position: 0,
    correctThisRound: 0
  }
};

let currentQuestion = null;

/* ==========================
   Utility
   ========================== */
function shuffle(array) {
  const arr = array.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function getVerbById(id) {
  return VERB_LIST.find(v => v.id === id);
}

function getRandomFromArray(arr, n) {
  const copy = arr.slice();
  const result = [];
  for (let i = 0; i < n && copy.length > 0; i++) {
    const idx = Math.floor(Math.random() * copy.length);
    result.push(copy[idx]);
    copy.splice(idx, 1);
  }
  return result;
}

/* ==========================
   ã¦-form generator
   ========================== */
function computeTeForm(verb) {
  const k = verb.kana;
  const last = k[k.length - 1];
  const stem = k.slice(0, -1);

  // irregulars
  if (verb.id === "iku")      return "ã„ã£ã¦";
  if (verb.group === "kuru")  return "ãã¦";
  if (verb.group === "suru")  return "ã—ã¦";

  if (verb.group === "suru_compound") {
    // ï½ã™ã‚‹ â†’ ï½ã—ã¦
    const base = k.slice(0, -2); // remove ã™ã‚‹
    return base + "ã—ã¦";
  }

  if (verb.group === "ichidan") {
    return stem + "ã¦";
  }

  // godan
  switch (last) {
    case "ã†":
    case "ã¤":
    case "ã‚‹":
      return stem + "ã£ã¦";
    case "ã‚€":
    case "ã¶":
    case "ã¬":
      return stem + "ã‚“ã§";
    case "ã":
      return stem + "ã„ã¦";
    case "ã":
      return stem + "ã„ã§";
    case "ã™":
      return stem + "ã—ã¦";
    default:
      return stem + "ã£ã¦";
  }
}

/* ==========================
   Distractor generator
   æ´»ç”¨ã¨ã—ã¦èª¤ã£ãŸãƒ†å½¢ã‚’ä½œã‚‹
   ========================== */
function generateWrongForms(verb) {
  const correct = verb.te;
  const k = verb.kana;
  const last = k[k.length - 1];
  const stem = k.slice(0, -1);
  const wrongs = new Set();

  function addCandidate(form) {
    if (form && form !== correct) wrongs.add(form);
  }

  if (verb.id === "iku") {
    // è¡Œã â†’ æ­£: ã„ã£ã¦ã€€èª¤ç”¨ä¾‹: ã„ã¦, ã„ãã¦
    addCandidate("ã„ã¦");
    addCandidate("ã„ãã¦");
  } else if (verb.group === "kuru") {
    // æ¥ã‚‹ â†’ æ­£: ãã¦ã€€èª¤ç”¨ä¾‹: ãã£ã¦, ãã£ã¦
    addCandidate("ãã£ã¦");
    addCandidate("ãã£ã¦");
  } else if (verb.group === "suru") {
    // ã™ã‚‹ â†’ æ­£: ã—ã¦ã€€èª¤ç”¨ä¾‹: ã™ã£ã¦, ã™ã¦
    addCandidate("ã™ã£ã¦");
    addCandidate("ã™ã¦");
  } else if (verb.group === "suru_compound") {
    // ï½ã™ã‚‹ â†’ æ­£: ï½ã—ã¦ã€€èª¤ç”¨ä¾‹: ï½ã™ã£ã¦, ï½ã™ã¦
    const base = k.slice(0, -2);
    addCandidate(base + "ã™ã£ã¦");
    addCandidate(base + "ã™ã¦");
  } else if (verb.group === "ichidan") {
    // ä¸€æ®µå‹•è©ãªã®ã«äº”æ®µã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å½“ã¦ã¯ã‚ã‚‹
    addCandidate(stem + "ã£ã¦");
    addCandidate(stem + "ã‚“ã§");
  } else if (verb.group === "godan") {
    // äº”æ®µã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å–ã‚Šé•ãˆã‚„ã€Œè¾æ›¸å½¢ï¼‹ã¦ã€
    switch (last) {
      case "ã†":
      case "ã¤":
      case "ã‚‹":
        addCandidate(stem + "ã‚“ã§"); // æœ¬å½“ã¯ï½ã£ã¦
        addCandidate(k + "ã¦");      // ï½ã†ã¦ï¼ï½ã¤ã¦ï¼ï½ã‚‹ã¦
        break;
      case "ã‚€":
      case "ã¶":
      case "ã¬":
        addCandidate(stem + "ã£ã¦"); // æœ¬å½“ã¯ï½ã‚“ã§
        addCandidate(k + "ã¦");
        break;
      case "ã":
        addCandidate(stem + "ã£ã¦"); // æœ¬å½“ã¯ï½ã„ã¦
        addCandidate(k + "ã¦");
        break;
      case "ã":
        addCandidate(stem + "ã‚“ã§"); // æœ¬å½“ã¯ï½ã„ã§
        addCandidate(k + "ã¦");
        break;
      case "ã™":
        addCandidate(stem + "ã™ã¦"); // æœ¬å½“ã¯ï½ã—ã¦
        addCandidate(k + "ã¦");
        break;
      default:
        addCandidate(k + "ã¦");
        addCandidate(stem + "ã‚“ã§");
    }
  }

  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆå¿µã®ãŸã‚ï¼‰
  if (wrongs.size < 2) {
    addCandidate(k + "ã¦");
    addCandidate(k + "ã§");
  }

  // 2ã¤ã ã‘é¸ã¶
  const arr = Array.from(wrongs);
  const chosen = getRandomFromArray(arr, 2);
  return chosen;
}

/* ==========================
   Choices
   ========================== */
function generateChoices(verb) {
  const wrongs = generateWrongForms(verb);
  const options = [
    { text: verb.te, correct: true },
    { text: wrongs[0], correct: false },
    { text: wrongs[1], correct: false }
  ];
  return shuffle(options);
}

/* ==========================
   Round logic
   ========================== */
function initLearningQueue() {
  state.learningQueue = shuffle(VERB_LIST.map(v => v.id));
  state.index = 0;
}

function buildRoundQuestionList() {
  const q = [];

  const reviewIds = Object.keys(state.reviewPool);
  const numReview = Math.min(REVIEW_PER_ROUND, reviewIds.length);
  q.push(...getRandomFromArray(reviewIds, numReview));

  while (q.length < TOTAL_PER_ROUND) {
    if (state.index >= state.learningQueue.length) {
      state.learningQueue = shuffle(VERB_LIST.map(v => v.id));
      state.index = 0;
    }
    const id = state.learningQueue[state.index++];
    if (!q.includes(id)) q.push(id);
  }

  state.currentRound.questionList = shuffle(q);
  state.currentRound.position = 0;
  state.currentRound.correctThisRound = 0;
}

function startNewRound() {
  buildRoundQuestionList();
  state.stats.roundsPlayed++;
  state.stats.currentStreak = 0;
  saveState();
  updateUI();
  showNextQuestion();
}

function showNextQuestion() {
  if (state.currentRound.position >= TOTAL_PER_ROUND) {
    return finishRound();
  }

  const id = state.currentRound.questionList[state.currentRound.position];
  currentQuestion = getVerbById(id);

  document.getElementById("kanaDisplay").textContent = currentQuestion.display;

  const options = generateChoices(currentQuestion);
  ["choice1", "choice2", "choice3"].forEach((btnId, i) => {
    const btn = document.getElementById(btnId);
    btn.textContent = options[i].text;
    btn.dataset.correct = options[i].correct ? "1" : "0";
    btn.disabled = false;
    btn.style.background = "#e0e0ff";
    btn.style.color = "#000";
  });

  const fb = document.getElementById("feedback");
  fb.textContent = "";
  fb.className = "feedback";

  document.getElementById("roundEnd").style.display = "none";
  document.getElementById("questionNumber").textContent =
    state.currentRound.position + 1;

  updateUI();
}

function finishRound() {
  document.getElementById("roundCorrect").textContent =
    state.currentRound.correctThisRound;
  document.getElementById("roundEnd").style.display = "block";

  checkBadges();
  renderBadges();
}

/* ==========================
   Answer handling
   ========================== */
function handleChoiceClick(e) {
  if (!currentQuestion) return;
  const btn = e.currentTarget;
  const correct = btn.dataset.correct === "1";

  ["choice1", "choice2", "choice3"].forEach(id => {
    document.getElementById(id).disabled = true;
  });

  state.stats.totalSeen++;

  const fb = document.getElementById("feedback");
  const jp = currentQuestion.display;
  const te = currentQuestion.te;
  const en = currentQuestion.en;
  const pt = currentQuestion.pt;

  if (correct) {
    state.stats.totalCorrect++;
    state.currentRound.correctThisRound++;
    state.stats.currentStreak++;
    const points = 10 + Math.max(0, state.stats.currentStreak - 1);
    state.stats.score += points;
    if (state.stats.currentStreak > state.stats.maxStreak) {
      state.stats.maxStreak = state.stats.currentStreak;
    }

    btn.style.background = "#22c55e";
    btn.style.color = "#fff";

    fb.textContent =
      `æ­£è§£ï¼ã€Œ${jp}ã€â†’ã€Œ${te}ã€\n${en}\n${pt}`;
    fb.className = "feedback correct";

    if (state.reviewPool[currentQuestion.id]) {
      state.reviewPool[currentQuestion.id].seen++;
      const r = state.reviewPool[currentQuestion.id];
      if (r.seen >= 3 && r.wrongCount <= r.seen / 2) {
        delete state.reviewPool[currentQuestion.id];
      }
    }

  } else {
    state.stats.currentStreak = 0;
    btn.style.background = "#ef4444";
    btn.style.color = "#fff";

    fb.textContent =
      `Wrongâ€¦ ã€Œ${jp}ã€ã¯ã€Œ${te}ã€ã§ã™ã€‚\n${en}\n${pt}`;
    fb.className = "feedback wrong";

    if (!state.reviewPool[currentQuestion.id]) {
      state.reviewPool[currentQuestion.id] = { wrongCount: 1, seen: 0 };
    } else {
      state.reviewPool[currentQuestion.id].wrongCount++;
    }
  }

  saveState();
  renderMistakes();

  setTimeout(() => {
    state.currentRound.position++;
    showNextQuestion();
  }, 800);
}

/* ==========================
   Badges
   ========================== */
function checkBadges() {
  const s = state.stats;
  if (s.totalSeen >= 10)  addBadge("first10");
  if (s.totalSeen >= 50)  addBadge("fifty");
  if (s.maxStreak >= 5)   addBadge("combo5");
  if (s.maxStreak >= 10)  addBadge("combo10");
  if (s.totalCorrect >= 100) addBadge("hundredCorrect");
  if (state.currentRound.correctThisRound === TOTAL_PER_ROUND)
    addBadge("perfect");
}
function addBadge(id) {
  if (!state.stats.badges.includes(id)) {
    state.stats.badges.push(id);
  }
}
function renderBadges() {
  const b = document.getElementById("badgeList");
  b.innerHTML = "";
  if (state.stats.badges.length === 0) {
    b.textContent = "No badges yet!";
    return;
  }
  const names = {
    first10: "10 questions",
    fifty: "50 questions",
    combo5: "Combo 5",
    combo10: "Combo 10",
    hundredCorrect: "100 correct",
    perfect: "Perfect round"
  };
  state.stats.badges.forEach(id => {
    const d = document.createElement("div");
    d.className = "badge";
    d.textContent = names[id] || id;
    b.appendChild(d);
  });
}

/* ==========================
   Mistake list
   ========================== */
function renderMistakes() {
  const m = document.getElementById("mistakeList");
  m.innerHTML = "";

  const list = Object.entries(state.reviewPool)
    .sort((a, b) => b[1].wrongCount - a[1].wrongCount);

  if (list.length === 0) {
    m.textContent = "No mistakes!";
    return;
  }

  list.forEach(([id, info]) => {
    const v = getVerbById(id);
    const row = document.createElement("div");
    row.className = "mistake-item";
    row.innerHTML = `<span>${v.display} â†’ ${v.te}</span><span>${info.wrongCount}</span>`;
    m.appendChild(row);
  });
}

/* ==========================
   Audio
   ========================== */
function playVerbAudio() {
  if (!currentQuestion) return;
  const u = new SpeechSynthesisUtterance(currentQuestion.display);
  u.lang = "ja-JP";
  speechSynthesis.cancel();
  speechSynthesis.speak(u);
}

/* ==========================
   Save & load
   ========================== */
function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function loadState() {
  const s = localStorage.getItem(STORAGE_KEY);
  if (s) {
    const parsed = JSON.parse(s);
    state = Object.assign(state, parsed);
  } else {
    initLearningQueue();
  }
}

/* ==========================
   UI
   ========================== */
function updateUI() {
  document.getElementById("score").textContent   = state.stats.score;
  document.getElementById("streak").textContent  = state.stats.currentStreak;
  document.getElementById("maxStreak").textContent = state.stats.maxStreak;
  document.getElementById("roundCount").textContent = state.stats.roundsPlayed;
}

/* ==========================
   Init
   ========================== */
function init() {
  // ã¦å½¢ã‚’è¨ˆç®—ã—ã¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦è¿½åŠ 
  VERB_LIST.forEach(v => {
    v.te = computeTeForm(v);
  });

  loadState();
  if (!state.learningQueue || state.learningQueue.length === 0) {
    initLearningQueue();
  }
  renderMistakes();
  renderBadges();
  updateUI();
  startNewRound();

  document.getElementById("choice1").onclick = handleChoiceClick;
  document.getElementById("choice2").onclick = handleChoiceClick;
  document.getElementById("choice3").onclick = handleChoiceClick;

  document.getElementById("playAudioBtn").onclick = playVerbAudio;
  document.getElementById("nextRoundBtn").onclick = startNewRound;
}

window.onload = init;
</script>
</body>
</html>
